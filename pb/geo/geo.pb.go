// Code generated by protoc-gen-go.
// source: pb/geo/geo.proto
// DO NOT EDIT!

/*
Package geo is a generated protocol buffer package.

It is generated from these files:
	pb/geo/geo.proto

It has these top-level messages:
	Request
	Point
	Result
*/
package geo

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// A latitude-longitude bounding box, represented as two diagonally opposite
// points "lo" and "hi".
type Request struct {
	Lo *Point `protobuf:"bytes,2,opt,name=lo" json:"lo,omitempty"`
	Hi *Point `protobuf:"bytes,3,opt,name=hi" json:"hi,omitempty"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Request) GetLo() *Point {
	if m != nil {
		return m.Lo
	}
	return nil
}

func (m *Request) GetHi() *Point {
	if m != nil {
		return m.Hi
	}
	return nil
}

// Points are represented as latitude-longitude pairs in the E7 representation
// (degrees multiplied by 10**7 and rounded to the nearest integer).
// Latitudes should be in the range +/- 90 degrees and longitude should be in
// the range +/- 180 degrees (inclusive).
type Point struct {
	Latitude  int32 `protobuf:"varint,1,opt,name=latitude" json:"latitude,omitempty"`
	Longitude int32 `protobuf:"varint,2,opt,name=longitude" json:"longitude,omitempty"`
}

func (m *Point) Reset()                    { *m = Point{} }
func (m *Point) String() string            { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()               {}
func (*Point) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Result struct {
	HotelIds []int32 `protobuf:"varint,1,rep,name=hotelIds" json:"hotelIds,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func init() {
	proto.RegisterType((*Request)(nil), "geo.Request")
	proto.RegisterType((*Point)(nil), "geo.Point")
	proto.RegisterType((*Result)(nil), "geo.Result")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Geo service

type GeoClient interface {
	// Obtains the Locations contained within the given Rectangle.
	BoundedBox(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Result, error)
}

type geoClient struct {
	cc *grpc.ClientConn
}

func NewGeoClient(cc *grpc.ClientConn) GeoClient {
	return &geoClient{cc}
}

func (c *geoClient) BoundedBox(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/geo.Geo/BoundedBox", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Geo service

type GeoServer interface {
	// Obtains the Locations contained within the given Rectangle.
	BoundedBox(context.Context, *Request) (*Result, error)
}

func RegisterGeoServer(s *grpc.Server, srv GeoServer) {
	s.RegisterService(&_Geo_serviceDesc, srv)
}

func _Geo_BoundedBox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GeoServer).BoundedBox(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Geo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "geo.Geo",
	HandlerType: (*GeoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BoundedBox",
			Handler:    _Geo_BoundedBox_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 181 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0x12, 0x28, 0x48, 0xd2, 0x4f,
	0x4f, 0xcd, 0x07, 0x61, 0xbd, 0x82, 0xa2, 0xfc, 0x92, 0x7c, 0x21, 0x66, 0x20, 0x53, 0xc9, 0x92,
	0x8b, 0x3d, 0x28, 0xb5, 0xb0, 0x34, 0xb5, 0xb8, 0x44, 0x48, 0x8c, 0x8b, 0x29, 0x27, 0x5f, 0x82,
	0x49, 0x81, 0x51, 0x83, 0xdb, 0x88, 0x4b, 0x0f, 0xa4, 0x2e, 0x20, 0x3f, 0x33, 0x0f, 0x2c, 0x9e,
	0x91, 0x29, 0xc1, 0x8c, 0x2e, 0xae, 0xa4, 0xc3, 0xc5, 0x0a, 0x51, 0x20, 0xc0, 0xc5, 0x91, 0x93,
	0x58, 0x92, 0x59, 0x52, 0x9a, 0x92, 0x2a, 0xc1, 0x08, 0x54, 0xc6, 0x2a, 0x24, 0xc8, 0xc5, 0x99,
	0x93, 0x9f, 0x97, 0x0e, 0x11, 0x02, 0x99, 0xc8, 0xaa, 0x24, 0xc5, 0xc5, 0x16, 0x94, 0x5a, 0x5c,
	0x9a, 0x03, 0x56, 0x9e, 0x91, 0x5f, 0x92, 0x9a, 0xe3, 0x99, 0x52, 0x0c, 0x54, 0xce, 0xac, 0xc1,
	0x6a, 0xa4, 0xc7, 0xc5, 0xec, 0x9e, 0x9a, 0x2f, 0xa4, 0xce, 0xc5, 0xe5, 0x94, 0x5f, 0x9a, 0x97,
	0x92, 0x9a, 0xe2, 0x94, 0x5f, 0x21, 0xc4, 0x03, 0xb6, 0x0a, 0xea, 0x38, 0x29, 0x6e, 0x28, 0x0f,
	0x64, 0x42, 0x12, 0x1b, 0xd8, 0x03, 0xc6, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd8, 0x93, 0xdd,
	0x7b, 0xd4, 0x00, 0x00, 0x00,
}
