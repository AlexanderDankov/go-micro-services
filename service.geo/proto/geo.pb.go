// Code generated by protoc-gen-go.
// source: service.geo/proto/geo.proto
// DO NOT EDIT!

/*
Package geo is a generated protocol buffer package.

It is generated from these files:
	service.geo/proto/geo.proto

It has these top-level messages:
	Location
	Point
	Rectangle
*/
package geo

import proto "github.com/golang/protobuf/proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

// A location is represented by a hotel at given point.
type Location struct {
	HotelID  int32  `protobuf:"varint,1,opt,name=hotelID" json:"hotelID,omitempty"`
	Location *Point `protobuf:"bytes,2,opt,name=location" json:"location,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}

func (m *Location) GetLocation() *Point {
	if m != nil {
		return m.Location
	}
	return nil
}

// Points are represented as latitude-longitude pairs in the E7 representation
// (degrees multiplied by 10**7 and rounded to the nearest integer).
// Latitudes should be in the range +/- 90 degrees and longitude should be in
// the range +/- 180 degrees (inclusive).
type Point struct {
	Latitude  int32 `protobuf:"varint,1,opt,name=latitude" json:"latitude,omitempty"`
	Longitude int32 `protobuf:"varint,2,opt,name=longitude" json:"longitude,omitempty"`
}

func (m *Point) Reset()         { *m = Point{} }
func (m *Point) String() string { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()    {}

// A latitude-longitude rectangle, represented as two diagonally opposite
// points "lo" and "hi".
type Rectangle struct {
	// One corner of the rectangle.
	Lo *Point `protobuf:"bytes,1,opt,name=lo" json:"lo,omitempty"`
	// The other corner of the rectangle.
	Hi *Point `protobuf:"bytes,2,opt,name=hi" json:"hi,omitempty"`
}

func (m *Rectangle) Reset()         { *m = Rectangle{} }
func (m *Rectangle) String() string { return proto.CompactTextString(m) }
func (*Rectangle) ProtoMessage()    {}

func (m *Rectangle) GetLo() *Point {
	if m != nil {
		return m.Lo
	}
	return nil
}

func (m *Rectangle) GetHi() *Point {
	if m != nil {
		return m.Hi
	}
	return nil
}

func init() {
}

// Client API for Geo service

type GeoClient interface {
	NearbyLocations(ctx context.Context, in *Rectangle, opts ...grpc.CallOption) (Geo_NearbyLocationsClient, error)
}

type geoClient struct {
	cc *grpc.ClientConn
}

func NewGeoClient(cc *grpc.ClientConn) GeoClient {
	return &geoClient{cc}
}

func (c *geoClient) NearbyLocations(ctx context.Context, in *Rectangle, opts ...grpc.CallOption) (Geo_NearbyLocationsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Geo_serviceDesc.Streams[0], c.cc, "/geo.Geo/NearbyLocations", opts...)
	if err != nil {
		return nil, err
	}
	x := &geoNearbyLocationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Geo_NearbyLocationsClient interface {
	Recv() (*Location, error)
	grpc.ClientStream
}

type geoNearbyLocationsClient struct {
	grpc.ClientStream
}

func (x *geoNearbyLocationsClient) Recv() (*Location, error) {
	m := new(Location)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Geo service

type GeoServer interface {
	NearbyLocations(*Rectangle, Geo_NearbyLocationsServer) error
}

func RegisterGeoServer(s *grpc.Server, srv GeoServer) {
	s.RegisterService(&_Geo_serviceDesc, srv)
}

func _Geo_NearbyLocations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Rectangle)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeoServer).NearbyLocations(m, &geoNearbyLocationsServer{stream})
}

type Geo_NearbyLocationsServer interface {
	Send(*Location) error
	grpc.ServerStream
}

type geoNearbyLocationsServer struct {
	grpc.ServerStream
}

func (x *geoNearbyLocationsServer) Send(m *Location) error {
	return x.ServerStream.SendMsg(m)
}

var _Geo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "geo.Geo",
	HandlerType: (*GeoServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "NearbyLocations",
			Handler:       _Geo_NearbyLocations_Handler,
			ServerStreams: true,
		},
	},
}
